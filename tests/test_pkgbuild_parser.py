"""
tests/test_pkgbuild_parser.py - Tests for PKGBUILD parsing via .SRCINFO.
"""
import pytest
import os
from pathlib import Path
from unittest.mock import patch, MagicMock

from gh-aur-updater.pkgbuild_parser import parse_pkgbuild_srcinfo, _parse_srcinfo_content
from gh-aur-updater.models import PKGBUILDData
from gh-aur-updater.exceptions import PKGBUILDParseError
import subprocess # For CalledProcessError

# Sample .SRCINFO content
SAMPLE_SRCINFO_SINGLE = """
# Generated by makepkg 6.1.0
pkgbase = mypackage
	pkgdesc = A sample package description.
	pkgver = 1.2.3
	pkgrel = 2
	epoch = 1
	url = https://example.com/mypackage
	arch = x86_64
	arch = any
	license = GPL3
	license = MIT
	makedepends = make
	makedepends = gcc
	depends = libfoo
	depends = libbar>=1.0
	source = mypackage-1.2.3.tar.gz
	source = https://another.example.com/patch.diff
	source = local_file.patch::https://example.com/local_file.patch
	sha256sums = SKIP
	sha256sums = 12345abcdef
pkgname = mypackage
"""

SAMPLE_SRCINFO_SPLIT = """
pkgbase = splitbase
	pkgdesc = Base for split package.
	pkgver = 0.5.0
	pkgrel = 1
	arch = any
	license = BSD
	makedepends = cmake
	source = splitbase-0.5.0.tar.xz
	sha256sums = SKIP

pkgname = splitbase-data
	depends = splitbase-lib
	groups = mygroup

pkgname = splitbase-lib
	pkgdesc = Library part of splitbase
	depends = zlib
"""

EMPTY_SRCINFO = ""
MALFORMED_SRCINFO = "pkgver\npkgrel=1"


def test_parse_srcinfo_content_single_package():
    data = _parse_srcinfo_content(SAMPLE_SRCINFO_SINGLE, Path("PKGBUILD.sample"))
    assert data['pkgbase'] == 'mypackage'
    assert data['pkgver'] == '1.2.3'
    assert data['pkgrel'] == '2'
    assert data['epoch'] == '1'
    assert data['url'] == 'https://example.com/mypackage'
    assert data['arch'] == ['x86_64', 'any']
    assert data['license'] == ['GPL3', 'MIT']
    assert data['makedepends'] == ['make', 'gcc']
    assert data['depends'] == ['libfoo', 'libbar>=1.0']
    assert data['source'] == [
        'mypackage-1.2.3.tar.gz',
        'https://another.example.com/patch.diff',
        'local_file.patch::https://example.com/local_file.patch'
    ]
    assert data['sha256sums'] == ['SKIP', '12345abcdef']
    assert data['pkgname'] == ['mypackage'] # pkgname is always a list

def test_parse_srcinfo_content_split_package():
    data = _parse_srcinfo_content(SAMPLE_SRCINFO_SPLIT, Path("PKGBUILD.split"))
    assert data['pkgbase'] == 'splitbase'
    assert data['pkgver'] == '0.5.0'
    assert data['pkgname'] == ['splitbase-data', 'splitbase-lib']
    assert data['makedepends'] == ['cmake']
    # Check one specific to a sub-package if needed, though .SRCINFO usually flattens some
    # For example, 'depends' for splitbase-data would not be directly in top-level 'depends'
    # The current parser puts all 'depends' lines into one list. A more advanced parser
    # might create nested structures for split packages if that level of detail is needed.
    # For now, it correctly aggregates all 'depends' lines found.

@patch('subprocess.run')
def test_parse_pkgbuild_srcinfo_success(mock_subprocess_run, tmp_path):
    pkgbuild_file = tmp_path / "PKGBUILD"
    pkgbuild_file.touch()

    mock_process = MagicMock()
    mock_process.returncode = 0
    mock_process.stdout = SAMPLE_SRCINFO_SINGLE
    mock_process.stderr = ""
    mock_subprocess_run.return_value = mock_process

    result = parse_pkgbuild_srcinfo(pkgbuild_file)

    assert isinstance(result, PKGBUILDData)
    assert result.pkgbase == "mypackage"
    assert result.pkgver == "1.2.3"
    assert str(result.current_version_obj) == "1:1.2.3-2"
    mock_subprocess_run.assert_called_once_with(
        ["makepkg", "--printsrcinfo", "--nocolor"],
        cwd=str(tmp_path), capture_output=True, text=True, check=False, env=pytest.approx(os.environ.copy())
    )

@patch('subprocess.run')
def test_parse_pkgbuild_srcinfo_makepkg_failure(mock_subprocess_run, tmp_path):
    pkgbuild_file = tmp_path / "PKGBUILD"
    pkgbuild_file.touch()

    mock_process = MagicMock()
    mock_process.returncode = 1
    mock_process.stdout = ""
    mock_process.stderr = "makepkg error details"
    mock_subprocess_run.return_value = mock_process
    
    # parse_pkgbuild_srcinfo now catches PKGBUILDParseError itself and returns None
    result = parse_pkgbuild_srcinfo(pkgbuild_file)
    assert result is None
    # To check log: caplog.records would contain the error

@patch('subprocess.run')
def test_parse_pkgbuild_srcinfo_no_output(mock_subprocess_run, tmp_path):
    pkgbuild_file = tmp_path / "PKGBUILD"
    pkgbuild_file.touch()

    mock_process = MagicMock()
    mock_process.returncode = 0
    mock_process.stdout = "" # No output
    mock_process.stderr = ""
    mock_subprocess_run.return_value = mock_process

    result = parse_pkgbuild_srcinfo(pkgbuild_file)
    assert result is None

def test_parse_pkgbuild_file_not_found():
    result = parse_pkgbuild_srcinfo(Path("/non/existent/PKGBUILD"))
    assert result is None

@patch('subprocess.run')
def test_parse_pkgbuild_srcinfo_no_pkgname(mock_subprocess_run, tmp_path):
    pkgbuild_file = tmp_path / "PKGBUILD"
    pkgbuild_file.touch()
    
    minimal_srcinfo_no_pkgname = "pkgbase = test\npkgver = 1.0" # Missing pkgname
    mock_process = MagicMock()
    mock_process.returncode = 0
    mock_process.stdout = minimal_srcinfo_no_pkgname
    mock_process.stderr = ""
    mock_subprocess_run.return_value = mock_process

    result = parse_pkgbuild_srcinfo(pkgbuild_file)
    assert result is None # Should fail if pkgname is missing
